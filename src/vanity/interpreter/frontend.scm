(define-library (vanity interpreter frontend)
  (import (vanity core) (vanity bytecode) (vanity compiler getopt) (vanity compiler config)
    (vanity compiler expand)
    (vanity compiler alpha-convert)
    (vanity compiler cps)
    (vanity compiler lower)
    (vanity compiler bytecode))
  (export ##vcore.vanity-main load)

  (define (extension file)
    (let extension-loop ((i (- (string-length file) 1)))
      (cond ((<= i 0) #f)
            ((eq? #\. (string-ref file i)) (substring file i))
            (else (extension-loop (- i 1))))))
  (define (basename file)
    (let ((seperator (if (eqv? platform 'windows) #\\ #\/)))
      (let loop ((i (- (string-length file) 1)))
        (cond ((<= i 0) file)
              ((eq? seperator (string-ref file i)) (substring file (+ i 1)))
              (else (loop (- i 1)))))))
  (define (dirname file)
    (let ((seperator (if (eqv? platform 'windows) #\\ #\/)))
      (let loop ((i (- (string-length file) 1)))
        (cond ((<= i 0) "./")
              ((eq? seperator (string-ref file i)) (substring file 0 i))
              (else (loop (- i 1)))))))
  (define realpath ##vcore.realpath)

  (define (filetype file)
    (let* ((ext (extension file))
           (lookup (assoc ext '((".vasm" . vasm) (".scm" . scheme)))))
      (if lookup (cdr lookup) (error "vanity: unknown file extension" ext))))

  (define (get-install-root)
    (if install-root
        install-root
        (sprintf "~A/" ((##vcore.function "VExePath")))))

  (define paths (list (sprintf "~Ainclude" (get-install-root))))
  (define (eval-scheme expr path)
    (let* ((architecture (if (eqv? platform 'windows) "windows_amd64" "sysv_amd64"))
           (expanded (expand-toplevel expr (if path (cons path paths) paths) architecture))
           (alpha (map alpha-convert expanded))
           (cps (map to-cps alpha))
           (opt (map (lambda (e) (optimize e #f)) cps))
           (bruijn (map bruijn-ify opt))
           (funs (to-functions bruijn #f))
           (bytecode (apply to-bytecode (cons #t (cons #f funs)))))
      (eval-vasm bytecode)))
  (define (load file)
    (define lang (filetype file))
    (define port (open-input-file file))
    (define evaluate
      (case lang
        ((vasm) (lambda (expr path) (eval-vasm expr)))
        ((scheme) eval-scheme)))
    (if (not port) (error "load: file does not exist" file))
    (let load-loop ()
      (let ((tape (read port)))
        (if (not (eof-object? tape))
            (call-with-values
              (lambda () (evaluate tape (dirname (realpath file))))
              (lambda args (load-loop))))))
    (close-port port))
  (define (display-help)
    (displayln "Usage: vanity [options]")
    (displayln "       vanity [options] file")
    (displayln "Launching without a file opens a repl.")
    (displayln "Options:")
    (displayln "  -I<dir>     Add the directory to the list to be searched for scheme header files")
    (displayln "  --scheme    Interpret the file as a scheme source file regardless of file extension")
    (displayln "  --vasm      Interpret the file as a vanity bytecode assembly file regardless of file extension")
    (displayln "  --help      You know about this")
    (displayln "  --version   Show version and build info"))
  (define (display-version)
    (printf "Vanity Scheme Interpreter ~A.~A~N" (car version) (cadr version))
    (displayln "Copyright (C) 2024 Richard Van Natta"))
  (define (##vcore.vanity-main)
    (define file #f)
    (define lang #f)
    (let main-loop ((args (getopt "I:" (command-line) '((help #f help) (version #f version) (scheme #f scheme) (vasm #f vasm)))))
      (if (not (null? args))
          (begin
            (case (caar args)
              ((#t)
               (if file (error "vanity: can only interpret one file"))
               (set! file (cdar args)))
              ((scheme vasm)
               (if lang (error "vanity: multiple languages declared"))
               (set! lang (caar args)))
              ((version)
               (display-version) (exit 0))
              ((help)
               (display-help) (exit 0))
              ((#\I)
               (let ((path (##vcore.realpath (cdar args))))
                 (if (not path) (error "vanity: path does not exist" path))
                 (set! paths (append paths (list path)))))
              (else
               (error "vanity: unknown command line option" (car args))))
            (main-loop (cdr args)))))
    (if (equal? file "-") (set! file #f))
    (cond ((and (not lang) (not file)) (set! lang 'scheme))
          ((and (not lang) file) (set! lang (filetype file)))
          (else #f))
    (let ((evaluate
           (case lang
            ((vasm) (lambda (expr path) (eval-vasm expr)))
            ((scheme) eval-scheme))))
      (define port
        (if file
            (let ((fd (open-input-file file)))
              (if (not fd) (error "vanity: file does not exist" fd))
              fd)
            (current-input-port)))
      (define is-tty? (and (not file) (##vcore.tty-port? (current-output-port))))
      (define first #t)
      (define restart #f)
      (define (handle-error err)
        (if is-tty?
            (begin
              (printf "recovered from error: ~A~N" err)
              (restart #f))
            (begin
              (error err))))
      (##vcore.register-sigint)
      (call/cc (lambda (k) (set! restart k)))
      ; FIXME too broad and a tad glitchy, need to just catch interrupts in this big net handler
      (with-exception-handler handle-error
        (lambda ()
         (let repl-loop ()
          (##vcore.garbage-collect #f)
          (if is-tty? (display "> "))
          (let ((tape (with-exception-handler handle-error (lambda () (read port)))))
            (if (not (eof-object? tape))
                (begin
                  (call-with-values
                    (lambda ()
                      (with-exception-handler handle-error
                        (lambda ()
                          (evaluate
                            tape
                            (if file
                                (dirname (realpath file))
                                #f)))))
                    (lambda rets
                      (if (and is-tty? (not (equal? rets `(,(let ((x #f)) (set! x #f))))))
                          (for-each writeln rets))))
                  (repl-loop))))))))))

(import (vanity core) (vanity interpreter frontend))
(##vcore.vanity-main)
