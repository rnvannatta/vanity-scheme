(define-library (vanity interpreter frontend)
  (import (vanity core) (vanity bytecode) (vanity compiler getopt)
    (vanity compiler expand)
    (vanity compiler alpha-convert)
    (vanity compiler cps)
    (vanity compiler lower)
    (vanity compiler bytecode))
  (export ##vcore.vanity-main)

  (define (extension file)
    (let loop ((i (- (string-length file) 1)))
      (cond ((<= i 0) #f)
            ((eq? #\. (string-ref file i)) (substring file i))
            (else (loop (- i 1))))))
  #;(define (realbasepath file)
    (let* ((proc (open-input-process (sprintf "realpath `dirname ~A`" file)))
           (ret (read-line proc)))
      (close-port proc)
      ret))

  (define (filetype file)
    (let* ((ext (extension file))
           (lookup (assoc ext '((".vasm" . vasm) (".scm" . scheme)))))
      (if lookup (cdr lookup) (error "vanity: unknown file extension. specify --scheme or --vasm" ext))))

  (define (##vcore.vanity-main)
    (define file #f)
    (define lang #f)
    (define path #f)
    (define evaluate #f)

    (define (eval-scheme expr)
      (let* ((expanded (expand-toplevel expr '() #;(cons path '())))
             (alpha (map alpha-convert expanded))
             (cps (map to-cps alpha))
             (opt (map (lambda (e) (optimize e #f)) cps))
             (bruijn (map bruijn-ify opt))
             (funs (to-functions bruijn #f))
             (bytecode (apply to-bytecode (cons #t (cons #f funs)))))
        (displayln bytecode)
        (eval-vasm bytecode)))
    (let loop ((args (getopt "" (command-line) '((scheme #f scheme) (vasm #f vasm)))))
      (if (not (null? args))
          (begin
            (case (caar args)
              ((#t)
               (if file (error "vanity: can only interpret one file"))
               (set! file (cdar args)))
              ((scheme vasm)
               (if lang (error "vanity: multiple languages declared"))
               (set! lang (caar args)))
              (else
               (error "vanity: unknown command line option" (car args))))
            (loop (cdr args)))))
    (if (equal? file "-") (set! file #f))
    (cond ((and (not lang) (not file)) (set! lang 'scheme))
          ((and (not lang) file) (set! lang (filetype file)))
          (else #f))
    (set! evaluate
      (case lang
        ((vasm) eval-vasm)
        ((scheme) eval-scheme)))
    #;(set! path (if file (realbasepath file) (realbasepath ".")))
    (let ()
      (define port
        (if file
            (let ((fd (open-input-file file)))
              (if (not fd) (error "vanity: file does not exist" fd))
              fd)
            (current-input-port)))
      (define is-tty? (and (not file) (##vcore.tty-port? (current-output-port))))
      (define first #t)
      (define restart #f)
      (define (handle-error err)
        (if is-tty?
            (begin
              (printf "recovered from error: ~A~N" err)
              (restart #f))
            (exit 1)))
      (##vcore.register-sigint)
      (call/cc (lambda (k) (set! restart k)))
      ; FIXME too broad and a tad glitchy, need to just catch interrupts in this big net handler
      (with-exception-handler handle-error
        (lambda ()
         (let loop ()
          (##vcore.garbage-collect #f)
          (if is-tty? (display "> "))
          (let ((tape (with-exception-handler handle-error (lambda () (read port)))))
            (if (not (eof-object? tape))
                (begin
                  (call-with-values
                    (lambda () (with-exception-handler handle-error (lambda () (evaluate tape))))
                    (lambda rets
                      (if (and is-tty? (not (equal? rets `(,(let ((x #f)) (set! x #f))))))
                          (for-each writeln rets))))
                  (loop))))))))))

(import (vanity core) (vanity interpreter frontend))
(##vcore.vanity-main)
