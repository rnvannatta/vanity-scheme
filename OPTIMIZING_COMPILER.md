# Becoming an Optimizing Compiler

Vanity Scheme does some optimization, but not much. To be frank, most of the optimization it does is to repair damage it did expanding macros and syntax and lowering the input scheme to a simpler continuation-passing style. It'll propogate some literals, it'll try to be careful about expanding letrec\*'s and internal definitions, and it'll delete superfluous let bindings and such that the cps-conversion introduced. In effect then, the code generated by Vanity is a sort-of okay translation of scheme source into a barebones cps, a half step ab ove a dumb algorithm. That barebones cps is then translated into a soup of C functions which is fed to a c compiler, which accepts it angrily and chews on it a long time. As it turns out C compilers do not like receiving thousands of functions per file.

That being said, the optimize pass that is still there is quite atrociously slow. Here's a breakdown of one of the heaviest files:

```
read: 0.000692s
expand: 0.710s
cps: 0.0175s
optimize: 6.537s
extract: 0.172s
transpile: 0.720s
compile: 11.232s
```

I haven't put my compiler to work hard enough for its programs to need the speed, though the compiler itself is starting to feel sluggish and its speed to compile itself is getting on my nerves. Particularly as I add to the standard library and make it more complete.

# Low Hanging Fruit: Trivial inlining

One of the lowest fruits hanging is trivial inlining that's always a win, for which there's no need for heruistics. And there's an embarrassingly easy one to do.

```
(define-library (foo)
  (import (vanity core))
  (export bar)
  (define (bar x)
    (cons (cons x 1) 2)))
```

Vanity implements `+` as an intrinsic, named `##vcore.+`, which compiles down to a C function, `VAdd`. And many other suspects are also intrinsics. 

```
(define-library (vanity core)
  (export + - / * cons car cdr pair? int? ... etc)
  (define + ##vcore.+)
  (define - ##vcore.-)
  (define cons ##vcore.cons)
  (define car ##vcore.car)
  ... etc)
```

Furthermore, a scarce few intrinsics like ##vcore.cons and ##vcore.car and ##vcore.eq? have inline implementations that are performed in-situ rather than calling out to a function and supplying a continuation if they are directly applied, reducing the strain on the poor C compiler which hates so many functions.

However, despite their trivial implementation, there is no inlining in Vanity yet. The foo library's use of cons above will not inline to ##vcore.cons, and it will not inline to the `VInlineCons()` macro when it compiles to C. Instead the `cons` closure will be looked up from the lexical environment of the foo library and called. And furthermore, the first `cons` above because it will compile to a full function call will also supply a continuation to call the second, straining the poor c compiler.

```
; pseudocode for cps-ified foo library
(define ##lib.foo
  (lambda (k)
    (let ((import (load-library '(vanity core))))
      (let ((cons (import 'cons)))
        (define (bar k x) (cons (lambda (r) (cons k r 2)) 1))
        (k (lambda (k x)
             (case ((bar) (k bar)))))))))
```

Inlining cons would give us:

```
(define ##lib.foo
  (lambda (k)
    (define (bar k x) (##vcore.cons (lambda (r) (##vcore.cons k r 2)) 1))
    (k (lambda (k x)
         (case ((bar) (k bar)))))))
```

Which would enable further inlining to immediate functions:

```
(define ##lib.foo
  (lambda (k)
    (define (bar k x) (k (##inline.cons (##inline.cons 1) 2)))
    (k (lambda (k x)
         (case ((bar) (k bar)))))))
```

The compiler generates header files from libraries, so the solution is to generate inline definitions for such trivial functions and to substitute them when it's safe.

There's a couple intersting procedures to inline: `call/cc`, `call-with-values`, and `values`:

```
(call/cc (lambda (ret) (ret 'ok)))
```

This cps-expands to 

```
(call/cc k (lambda (k ret) (ret k 'ok)))
```

call/cc is exposing the underlying continuation machinery with a trampoline. It can't be implemented in natural scheme code, but must be handwritten in continuation-passing-style:

```
(define (##vcore.call/cc k thunk)
  (thunk k (lambda (_ x) (k x))))
```

Instead of actually calling call/cc to set up the trampoline, when the ##vcore.call/cc intrinsic is directly called with a lambda, we can rewrite the expression to elide it:

```
(call/cc k (lambda (k ret) (ret k 'ok))) => // inline call/cc
(let ((ret (lambda (_ x) (k x))))
  (ret k 'ok)) => // eliminate unused argument
(let ((ret (lambda (x) (k x))))
  (ret 'ok)) => // eta conversion
(let ((ret k))
  (ret 'ok)) => // copy propogation
(k 'ok)
```

Likewise `values` is implemented as

```
(define (values . args)
  (call/cc (lambda (k) (apply k args))))
```

Its practical usage inlines nicely though:

```
(define (sincos x)
  (values (sin x) (cos x)))
```

in cps is

```
(define (sincos k x)
  (sin (lambda (r1) (cos (lambda (r2) (values k r1 r2)))) x))
```

and values inlines super cleanly to:

```
(define (sincos k x)
  (sin (lambda (r1) (cos (lambda (r2) (k r1 r2)))) x))
```

Inlining call-with-values also goes great:

```
(call-with-values
  (lambda () (sincos 2))
  (lambda (y x) (printf "~A ~A" x y)))
```

call-with-values similarly must be implemented in cps as:

```
(define (call-with-values k producer consumer)
  (producer (lambda args (apply k consumer k args))))
```

But it inlines super nice:

```
(call-with-values k
  (lambda (k) (sincos k 2))
  (lambda (k y x) (printf k "~A ~A" x y))) =>
((lambda (k) (sincos k 2)) (lambda (y x) (printf k "~A ~A x y"))) =>
(sincos (lambda (y x) (printf "~A ~A x y")) 2)
```

In terms of impact, my pattern matching macro makes heavy use of call/cc and call-with-values, and the compiler naturally uses pattern matching extensively to identify syntax and extract data from the syntax.
