(import (vanity core) (vanity assert))

(define input (open-input-file "input"))

(define (decode-stack line num-boxes)
  (let loop ((i 0))
    (if (< i num-boxes)
          (cons (string-ref line (+ 1 (* i 4))) (loop (+ i 1)))
        '())))

(define (zip . lists)
  (apply map (cons list lists)))

(define (read-stack port)
  (define (trim stack)
    (if (eq? (car stack) #\space)
        (trim (cdr stack))
        stack))
  (define (read-unzipped i)
    (if (< i 8)
        (let ((line (read-line port)))
          (cons (decode-stack line 9) (read-unzipped (+ i 1))))
        '()))
  (map trim (apply zip (read-unzipped 0))))


(define stack (read-stack input))
(read-line input)
(read-line input)

(define (strtok str tok)
  (let ((len (string-length str)))
    (let loop ((start 0) (end 0))
      (cond ((= end len) (cons (substring str start end) '()))
            ((eq? (string-ref str end) tok) (cons (substring str start end) (loop (+ end 1) (+ end 1))))
            (else (loop start (+ end 1)))))))
(define (decode-move line)
  (let ((toks (strtok line #\space)))
    (map string->number (list (list-ref toks 1) (list-ref toks 3) (list-ref toks 5)))))

(define (apply-move! num start end)
  (define (move-one! start end stack)
    (define (drop-one! stack x)
      (let loop ((stack stack) (x x))
        (if (= x 1)
            (let ((dropped (caar stack)))
              (set-car! stack (cdr (car stack)))
              dropped)
            (loop (cdr stack) (- x 1)))))
    (define (add-one! stack x val)
      (let loop ((stack stack) (x x))
        (if (= x 1)
            (set-car! stack (cons val (car stack)))
            (loop (cdr stack) (- x 1)))))
    (add-one! stack end (drop-one! stack start)))
  (if (= num 0) stack
      (begin
        (move-one! start end stack)
        (apply-move! (- num 1) start end))))

;(display (decode-move (read-line input))) (newline)
;(define move (decode-move (read-line input)))
;(apply apply-move! move)
;(display stack)
(let loop ()
  (let ((line (read-line input)))
    (if (eof-object? line)
        (let ((out (open-output-string)))
          ;(display "task 1:")
          (map (lambda (x) (display x out)) (map car stack))
          (assert-equal (get-output-string out) "WCZTHTMPS")
          ;(map display (map car stack))
          (close-port out)
          #;(newline))
        (begin (apply apply-move! (decode-move line)) (loop)))))


(close-port input)
(define input (open-input-file "input"))

(define stack (list->vector (read-stack input)))
(read-line input)
(read-line input)

(define (take lst x)
  (if (eq? x 0)
      '()
      (cons (car lst) (take (cdr lst) (- x 1)))))
(define (drop lst x)
  (if (eq? x 0)
      lst
      (drop (cdr lst) (- x 1))))

(define (apply-move-9001! num start end)
  (define (move! num start end stack)
    (define (drop! stack num x)
      (let ((dropped (take (vector-ref stack (- x 1)) num)))
        (vector-set! stack (- x 1) (drop (vector-ref stack (- x 1)) num))
        dropped))
    (define (add! stack x vals)
      (vector-set! stack (- x 1) (append vals (vector-ref stack (- x 1)))))
    (add! stack end (drop! stack num start)))
  (move! num start end stack))

(let loop ()
  (let ((line (read-line input)))
    (if (eof-object? line)
        (let ((out (open-output-string)))
          (parameterize ((current-output-port out))
            #;(display "task 2:")
            #;(display stack)
            (let loop ((i 0))
              (if (>= i (vector-length stack))
                  #f
                  (begin
                    (display (car (vector-ref stack i)))
                    (loop (+ i 1))))))
          (assert-equal (get-output-string out) "BLSGJSDTS")
          (close-port out)
          #;(newline))
        (begin (apply apply-move-9001! (decode-move line)) (loop)))))

(close-port input)
