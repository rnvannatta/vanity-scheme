; Copyright 2023 Richard N Van Natta
;
; This file is part of the Vanity Scheme Compiler.
;
; The Vanity Scheme Compiler is free software: you can redistribute it
; and/or modify it under the terms of the GNU General Public License as
; published by the Free Software Foundation, either version 3 of the
; License, or (at your option) any later version.
; 
; The Vanity Scheme Compiler is distributed in the hope that it will be
; useful, but WITHOUT ANY WARRANTY; without even the implied warranty
; of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
; General Public License for more details.
;
; You should have received a copy of the GNU General Public
; License along with the Vanity Scheme Compiler.
;
; If not, see <https://www.gnu.org/licenses/>.
;
; This work is published with additional permission under GNU GPL
; Version 3.0 Section 7, the Vanity Scheme Macro Exceptions, which
; should have been included with the Vanity Scheme Compiler.
;
; If not, visit <https://github.com/rnvannatta>

(define-library "transpile"
  (import (vanity core) "utils" "match" "variables")
  (export bruijn-ify to-functions printout)
; Strips the names from bound variables and replaces them with indices
; free variables are assumed to be builtin functions
  (define (list-index p l)
    (let loop ((l l) (i 0))
      (cond ((null? l) #f)
            ((p (car l)) i)
            (else (loop (cdr l) (+ i 1))))))

  (define (bruijn-ify expr)
    (define (lookup depth env x)
      (cond
        ((null? env) x)
        ((list-index (lambda (e) (eqv? x e)) (car env)) => (lambda (idx) (list 'bruijn x depth idx)))
        (else (lookup (+ 1 depth) (cdr env) x))))
    (define (undot lst)
      (if (pair? lst)
          (cons (car lst)
                (undot (cdr lst)))
          (if (null? lst) '()
              (cons lst '()))))
    (define (bruijn-lambda env lamb)
      (match lamb
        (((xs ...) body) `(,(length xs) ,(iter (cons xs env) body)))
        ((xs body)
         (let ((proper-xs (undot xs)))
          `(,(- (length proper-xs) 1) + ,(iter (cons proper-xs env) body))))))
    (define (iter env expr)
      (match expr
        (('lambda (xs ...) body)
         `(lambda ,(length xs) ,(iter (cons xs env) body)))
        (('lambda xs body)
         (let ((proper-xs (undot xs)))
          `(lambda ,(- (length proper-xs) 1) + ,(iter (cons proper-xs env) body))))
        (('case-lambda . cases)
         `(case-lambda . ,(map (lambda (e) (bruijn-lambda env e)) cases)))
        (('continuation (x) body)
         `(continuation 1 ,(iter (cons (list x) env) body)))
        (('quote . _)
         expr)
        (('##inline f . xs)
         `(##inline ,f . ,(map (lambda (x) (iter env x)) xs)))
        ((f xs ...)
         (cons (iter env f) (map (lambda (x) (iter env x)) xs)))
        (x
         (if (symbol? x) (lookup 0 env x) x))
        (else (error "No matching case" expr))))
    (define (doit expr)
      (iter '() expr))
    (match expr
      (('##vcore.declare f l)
       `(##vcore.declare ,f ,(doit l)))
      (else (doit expr))))

  ; replaces lambdas and defines with explicit close statements on functions, and
  ; gathers the functions into a list, and gathers literals into a list and replaces
  ; with references
  (define curlambda 0)
  (define curcont 0)
  (define (to-functions exprs)
    (define (genlambda fun)
        (set! curlambda (+ curlambda 1))
        (string->symbol (sprintf "~A_lambda~A" fun curlambda)))
    (define (gencont fun)
        (set! curcont (+ curcont 1))
        (string->symbol (sprintf "~A_k~A" fun curcont)))
    (define functions '())
    (define literal-table '())
    ; TODO drop the unnecessary quotes from nonsymbols, ie turn '"foo" into just "foo"
    ; then split out lift-symbol into a seperate function
    (define (lift-literal x)
      (cond ((integer? x) x)
            ((number? x) x)
            ((char? x) x)
            ((eq? x #t) x)
            ((eq? x #f) x)
            ((null? x) x)
            ((string? x)
             (let ((lookup (assoc x literal-table)))
               (if lookup `(##string ,(cdr lookup))
                   (begin
                     (set! literal-table (cons (cons x (gensym "string")) literal-table))
                     `(##string ,(cdar literal-table))
                   )
               )))
            ((symbol? x)
             (if (not (assv x literal-table))
                 (set! literal-table (cons (cons x '()) literal-table)))
             x)
            (else (error "Unknown literal type" x))))
    (define (iter-lambda fun lamb) 
      (match lamb
        ((n body)
         `(,n ,(iter-apply fun body)))
        ((n '+ body)
         `(,n + ,(iter-apply fun body)))))
    (define (iter-atom fun expr)
      (match expr
        (('bruijn . _) expr)
        (('lambda n body)
         (let ((lamb (genlambda fun)))
           (set! functions (cons `(,lamb #t (,n ,(iter-apply fun body))) functions))
           `(close ,lamb)))
        (('lambda n '+ body)
         (let ((lamb (genlambda fun)))
           (set! functions (cons `(,lamb #t (,n + ,(iter-apply fun body))) functions))
           `(close ,lamb)))
        (('case-lambda . cases)
         (let ((lamb (genlambda fun)))
           (set! functions (cons `(,lamb #t . ,(map (lambda (e) (iter-lambda fun e)) cases)) functions))
           `(close ,lamb)))
        (('continuation n body)
         (let ((k (gencont fun)))
           (set! functions (cons `(,k #t (,n ,(iter-apply fun body))) functions))
           `(close ,k)))
        (('quote x)
         `(quote ,(lift-literal x)))
        (('##inline f . xs)
         `(##inline ,f . ,(map (lambda (x) (iter-atom fun x)) xs)))
        (x (if (symbol? x) x (lift-literal x)))))
    (define (iter-apply fun expr)
      (match expr
        (('define k y x)
         `(define ,k ,(lift-literal y) ,(iter-atom (mangle-symbol y) x)))
        (('set! k ('bruijn name . rest) x)
         `(set! ,(iter-atom fun k) (bruijn ,name . ,rest) ,(iter-atom (mangle-symbol name) x)))
        (('set! k y x)
         `(set! ,(iter-atom fun k) ,(lift-literal y) ,(iter-atom (mangle-symbol y) x)))
        (('if p x y)
         `(if ,(iter-atom fun p) ,(iter-apply fun x) ,(iter-apply fun y)))
        ((('lambda n body) . xs)
         (let ((lamb (genlambda fun)))
           (set! functions (cons `(,lamb #f (,n ,(iter-apply fun body))) functions))
           `((close ,lamb) . ,(map (lambda (x) (iter-atom fun x)) xs))))
        ((xs ...)
         (map (lambda (x) (iter-atom fun x)) xs))))
    (define (iter fun expr)
      (match expr
        (('bruijn . _) expr)
        (('lambda . _) (iter-atom fun expr))
        (('case-lambda . _) (iter-atom fun expr))
        (('continuation . _) (iter-atom fun expr))
        (('quote . _) (iter-atom fun expr))
        (('##inline . _) (iter-atom fun expr))
        ((_ . _) (iter-apply fun expr))
        (else (iter-atom fun expr))))
    (define (iter-declare d)
      (match d
        (('##vcore.declare f l)
         (cons f (cadr (iter f l))))))
    ; TODO lift these three up and out
    (define (make-list n k)
      (if (= 0 n)
          '()
          (cons k (make-list (- n 1) k))))
    (define (list-set! l x v)
      (if (= x 0)
          (set-car! l v)
          (list-set! (cdr l) (- x 1) v)))
    (define (multi-partition f n l)
      (let loop ((ret (make-list n '())) (l l))
        (if (null? l)
            (apply values (map reverse ret))
            (begin
              (let ((split (f (car l))))
                (list-set! ret split (cons (car l) (list-ref ret split))))
              (loop ret (cdr l))))))
    (call-with-values
      (lambda ()
        (multi-partition
          (lambda (e)
            (match e
              (('##vcore.declare . _) 1)
              (else 0)))
          2 exprs))
      (lambda (globals declares)
        (let ((toplevels (map (lambda (e) (iter "global" e)) globals))
              (declares (map iter-declare declares)))
          (list literal-table functions declares toplevels)))))

  (define (printout debug? shared? literal-table functions declares toplevels)
    (define (print-global sym)
      (let ((builtin (lookup-intrinsic sym)))
        (if builtin
            (printf "VEncodeClosure((VClosure[]){VMakeClosure(~A,NULL)})" (lookup-intrinsic sym))
            (printf "VLookupGlobalVarFast(\"~A\")" sym))))
    (define (print-string s)
      (display #\")
      (let loop ((i 0))
        (if (< i (string-length s))
            (begin
              (case (string-ref s i)
                ((#\alarm) (display "\\a"))
                ((#\backspace) (display "\\b"))
                ((#\tab) (display "\\t"))
                ((#\newline) (display "\\n"))
                ((#\return) (display "\\r"))
                ((#\?) (display "\\?")) ; stupid trigraphs
                ((#\" #\\) (display #\\) (display (string-ref s i)))
                (else (display (string-ref s i))))
              (loop (+ i 1)))))
      (display #\"))
    (define (escape-string s)
      (let ((len (string-length s))
            (port (open-output-string)))
        (let loop ((i 0))
          (if (< i len)
              (begin
                (case (string-ref s i)
                  ((#\alarm) (display "\\a" port))
                  ((#\backspace) (display "\\b" port))
                  ((#\tab) (display "\\t" port))
                  ((#\newline) (display "\\n" port))
                  ((#\return) (display "\\r" port))
                  ((#\?) (display "\\?" port)) ; stupid trigraphs
                  ((#\" #\\) (display #\\ port) (display (string-ref s i) port))
                  (else (display (string-ref s i) port)))
                (loop (+ i 1)))))
        (let ((ret (get-output-string port)))
          (close-port port)
          ret)))
    (define (escape-char c)
      (case c
        ((#\alarm) "\\a")
        ((#\backspace) "\\t")
        ((#\tab) "\\t")
        ((#\newline) "\\n")
        ((#\return) "\\r")
        ((#\\) "\\\\")
        ((#\') "\\'")
        (else c)))
    (define (print-literal-string x)
      (printf "VEncodePointer(&~A.sym, VPOINTER_OTHER)" (mangle-symbol x)))
    (define (print-literal x)
      (cond ((integer? x) (printf "VEncodeInt(~Al)" x)) ; FIXME bounds check
            ((number? x) (printf "VEncodeNumber(~A)" x)); FIXME fractions
            ((char? x) (printf "VEncodeChar('~A')" (escape-char x)))
            ((eq? x #t) (printf "VEncodeBool(true)"))
            ((eq? x #f) (printf "VEncodeBool(false)"))
            ((string? x)
             (display "V_BLOB_LITERAL(VSTRING, ")
             (print-string x)
             (display ")"))
            ((symbol? x)
             (printf "VEncodePointer(&~A.sym, VPOINTER_OTHER)" (mangle-symbol x))
             #;(printf "V_BLOB_LITERAL(VSYMBOL, \"~A\")" x))
            (else (error "Unknown literal type" x))))
    (define (print-literal-declaration lit)
      (cond ((symbol? (car lit))
             (let* ((mangled (mangle-symbol (car lit)))
                    (escaped (escape-string (symbol->string (car lit))))
                    (len (+ (string-length (symbol->string (car lit))) 1)))
               (printf "static struct { VBlob sym; char bytes[~A]; } ~A = { { VSYMBOL, ~A }, \"~A\" };~N"
                len mangled len escaped)))
            ((string? (car lit))
             (let* ((mangled (mangle-symbol (cdr lit)))
                    (escaped (escape-string (car lit)))
                    (len (+ (string-length (car lit)) 1)))
               (printf "static struct { VBlob sym; char bytes[~A]; } ~A = { { VSTRING, ~A }, \"~A\" };~N"
                len mangled len escaped)))
            (else (error "unknown entry in literal table"))))
    (define (print-builtin-apply f xs tail-call?)
      ; FIXME implement V_TAIL_CALL_FUNC
      (printf "    V_CALL_FUNC(~A" (lookup-intrinsic f))
      (for-each
        (lambda (x)
         (printf ",~N      ")
         (print-expr x))
        xs)
      (printf "~N    );~N"))
    (define (print-closure-apply f xs tail-call?)
      (if tail-call?
          (printf "    V_TAIL_CALL_CLOSURE(env, ")
          (printf "    V_CALL_CLOSURE("))
      (match f
        (('close fun) (printf "(VClosure[]){VMakeClosure(~A, env)}" fun))
        (else
          (display "VDecodeClosureApply(")
          (print-expr f)
          (display ")")))
      (for-each
        (lambda (x)
         (printf ",~N      ")
         (print-expr x))
        xs)
      (printf "~N    );~N"))
    
    ; should always be a tail call eh
    (define (print-define-global k y x tail-call?)
      (printf "    V_CALL_CLOSURE((VClosure[]){VMakeClosure(VDefineGlobalVar, env)},~N      ")
      (print-expr k)
      (printf ",~N      ")
      (print-literal y)
      (printf ",~N      " )
      (print-expr x)
      (printf "~N    );~N"))
    (define (print-set k y x tail-call?)
      (match y
        (('bruijn name up right)
         (printf "    V_CALL_CLOSURE((VClosure[]){VMakeClosure(VSetEnvVar, env)},~N      ")
         (print-expr k)
         (printf ",~N      ~A, ~A,~N      " up right)
         (print-expr x)
         (printf "~N    );~N"))
        (sym
         (if (symbol? sym)
             (begin
               (printf "    V_CALL_CLOSURE((VClosure[]){VMakeClosure(VSetGlobalVar, env)},~N      ")
               (print-expr k)
               (printf ",~N      ")
               (print-literal sym)
               (printf ",~N      " )
               (print-expr x)
               (printf "~N    );~N")
             )
             (error "set!'s first argument is not a symbol")))))
    (define (print-inline f xs)
      (let ((inline (lookup-inline f)))
        (if (not inline) (error "unknown inline" f))
        (printf "~A(~N" inline)
        (if (not (null? xs))
            (begin
              (print-expr (car xs))
              (for-each
                (lambda (x)
                 (printf ",~N      ")
                 (print-expr x))
                (cdr xs))))
        (printf "~N    )~N")))
    ; FIXME split this out into print-apply and print-atom
    (define (print-expr expr)
      (match expr
        (('quote ()) (display "VNULL"))
        ; FIXME
        (('quote ('##string x)) (print-literal-string x))
        (('quote x) (print-literal x))
        (('close fun) (printf "VEncodeClosure((VClosure[]){VMakeClosure(~A, env)})" fun))
        (('bruijn name up right)
         (cond ((= up 0) (printf "env->vars[~A]" right))
               ((= up 1) (printf "env->up->vars[~A]" right))
               ((= up 2) (printf "env->up->up->vars[~A]" right))
               ((= up 3) (printf "env->up->up->up->vars[~A]" right))
               (else (printf "VGetArg(env, ~A, ~A)" up right))))
        (('if p a b)
         (displayln "if(VDecodeBool(") (print-expr p) (displayln ")) {") 
         (print-expr a)
         (displayln "} else {")
         (print-expr b)
         (displayln "}"))
        (('set! k y x)
         (print-set k y x #f))
        (('define k y x)
         (print-define-global k y x #f))
        (('##inline f . xs)
         (print-inline f xs))
        (('##string x)
         (if (null? x) (error "fugg" literal-table))
         (print-literal-string x))
        ((f xs ...)
         (if (lookup-intrinsic f)
             (print-builtin-apply f xs #f)
             (print-closure-apply f xs #f)))
        (x (if (symbol? x) (print-global x) (print-literal x)))
        (else (error "malformed expression" expr))))
    (define (print-define funs)
      (printf "    V_LETREC(env")
      (for-each (cut printf ", ~A" <>) funs)
      (printf ");~N"))
    (define (print-fun-case fun)
      (let ((name (car fun)))
       (printf "static void ~A(VEnv * env) {~N" name)
       (if debug?
           (begin
             (printf " static VDebugInfo dbg = { \"~A\" };~N" name)
             (printf " VRecordCall(&dbg);~N")))
       (printf " V_GC_CHECK(~A, env) {~N" name)
       (if (cadr fun)
           (for-each
             (lambda (lamb)
               (match lamb
                ((num body)
                 (printf " if (env->num_vars == ~A) {~N" num)
                 (printf "  // ~S~N" body)
                 (print-expr body)
                 (printf " } else"))
                ((num '+ body)
                 (printf " if (env->num_vars >= ~A) {~N" num)
                 (printf "  // ~S~N" body)
                 (printf "  V_GATHER_VARARGS(&env, ~A);~N" num)
                 (print-expr body)
                 (printf " } else"))
                (else (error "malformed case lambda" fun))))
             (cddr fun))
           (match (caddr fun)
              ((num body)
               (printf "  // ~S~N" body)
               (print-expr body))
              ((num '+ body)
               (printf "  // ~S~N" body)
               (printf "  V_GATHER_VARARGS(&env, ~A);~N" num)
               (print-expr body))
              (else (error "malformed case lambda" fun))))
       (if (cadr fun)
           (begin
             (printf " {~N")
             (printf "  VError(\"Not enough arguments to ~A, got ~~D~~N\"~N" name)
             (for-each  
              (lambda (lamb)
                (match lamb
                  ((num body)
                   (printf "  \"-- expected ~A~~N\"~N" num))
                  ((num '+ body)
                   (printf "  \"-- expected ~A or more~~N\"~N" num))
                  (else (error "malformed case lambda"))))
              (cddr fun))
             (printf "  , env->num_vars);~N")
             (printf " }~N")))
       (printf " }~N")
       (printf "}~N")))
    (define (print-toplevel i expr)
      (printf "void toplevel~A() {~N" i)
      (displayln "    VEnv * env = NULL;")
      (print-expr expr)
      (displayln "}"))
    (define (print-declare declare)
      (printf "void (*~A)(VEnv*) = ~A;~N" (car declare) (cdr declare)))
    (define (print-main toplevels)
      (for-each (cut print-toplevel <> <>) (iota (length toplevels)) toplevels)

      (printf "int main(int argc, char ** argv) {~N")
      (printf "  void (*toplevels[])() = {~N")
      (for-each (lambda (i) (printf "    toplevel~A," i)) (iota (length toplevels)))
      (printf "  ~N};~N")
      (printf "  VArgc = argc; VArgv = argv;")
      (printf "  return VStart(sizeof toplevels / sizeof *toplevels, toplevels);~N")
      (displayln "}")
  )

    (let ((print-main? (not (null? toplevels)))
          (functions (reverse functions)))
      (displayln "#include \"vscheme/vruntime.h\"")
      (displayln "#include \"vscheme/vlibrary.h\"")
      (displayln "#include \"vscheme/vinlines.h\"")
      (for-each print-literal-declaration literal-table)
      (for-each print-fun-case functions)
      (for-each print-declare declares)

      (if (and shared? print-main?)
          (error "shared library has toplevel expressions or defines"))
      (if print-main?
          (print-main toplevels))
      print-main?))
)
