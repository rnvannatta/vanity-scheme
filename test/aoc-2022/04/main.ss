(import (vanity core) (vanity assert))
(define (strchr str chr)
  (let ((end (string-length str)))
    (let loop ((i 0))
      (cond ((>= i end) #f)
            ((eq? (string-ref str i) chr) i)
            (else (loop (+ i 1)))))))
(define (read-pair port)
  (define (read-row str)
    (let* ((sep (strchr str #\-))
           (str1 (substring str 0 sep))
           (str2 (substring str (+ sep 1))))
      (cons (string->number str1) (string->number str2))))
  (let* ((str (read-line port)))
    (if (eof-object? str) #f
        (let* ((sep (strchr str #\,))
               (str1 (substring str 0 sep))
               (str2 (substring str (+ sep 1))))
          (cons (read-row str1) (read-row str2))))))

(define (inside? a b)
  (define (a-inside-b? a b)
    (and (>= (car a) (car b))
         (<= (cdr a) (cdr b))))
  (or (a-inside-b? a b) (a-inside-b? b a)))

(define (eclipse port)
  (let ((pair (read-pair port)))
    ;(display pair) (newline)
    (if pair
        (if (inside? (car pair) (cdr pair)) 1 0)
        #f)))

(define (num-eclipses port)
  (let loop ((acc 0))
    (cond ((eclipse port) => (lambda (x) (loop (+ x acc))))
          (else acc))))

(define input (open-input-file "input"))
;(display "task 1:")
;(display (num-eclipses input))
;(newline)
(assert-equal (num-eclipses input) 487)
(close-port input)

(define (overlaps? a b)
  (and (>= (cdr a) (car b))
       (<= (car a) (cdr b))))
(define (overlap port)
  (let ((pair (read-pair port)))
    (if pair
        (if (overlaps? (car pair) (cdr pair)) 1 0)
        #f)))
(define (num-overlaps port)
  (let loop ((acc 0))
    (cond ((overlap port) => (lambda (x) (loop (+ x acc))))
          (else acc))))

(define input (open-input-file "input"))
;(display "task 2:")
;(display (num-overlaps input))
;(newline)
(assert-equal (num-overlaps input) 849)
(close-port input)
