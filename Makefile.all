# This is unideal, specify object files instead of source files. Need to create dummy .d files for assembly and scm
SRC := variables.scm match.scm utils.scm getopt.scm expand.scm cps.scm transpile.scm frontend.scm ffi.scm
RUNTIME_SRC := vruntime.c vlibrary.c vread.c
ASSEMBLY_SRC := vapply-linux-x64.s

INLINE_SRC := $(addprefix include/vscheme/, vinlines.h vruntime.h)

DAYS := 01 02 03 04 05 06 07 08
AOC := $(addprefix aoc-2022/, $(addsuffix /main.ss, $(DAYS)))
TEST_SRC := fact.scm ack.scm multilib.scm core.scm list.scm listfunc.scm match.scm io.scm callcc.scm callvalues.scm ffitest.scm ffiimport.scm $(AOC)

HOME_DIR := $(shell echo ~)
INSTALL_DIR := $(HOME_DIR)/.local

LIBS := -lm -ldl -lpthread
INCLUDES := include $(HOME_DIR)/.local/include
CFLAGS := -fPIC -Wall -Wextra -Wno-unused-parameter -Wno-sign-compare -Werror=implicit-function-declaration -Werror=incompatible-pointer-types -Werror=cast-function-type -Wno-missing-field-initializers -Werror=varargs -masm=intel

IFLAGS := $(addprefix -I, $(INCLUDES))

vpath %.h src $(INCLUDES)

DEP = $(addprefix build/, $(RUNTIME_SRC:.c=.d))
OBJ = $(addprefix build/, $(SRC:.scm=.o)) build/ffi.tab.o build/ffi.lex.o
RUNTIME_OBJ = $(addprefix build/, $(RUNTIME_SRC:.c=.o))
RUNTIME_OBJ += $(addprefix build/, $(ASSEMBLY_SRC:.s=.o))

BOOT = $(addprefix bin/bootstrap/src/, $(SRC:.scm=.c))
BOOT += $(addprefix bin/bootstrap/runtime/, $(ASSEMBLY_SRC) $(RUNTIME_SRC))

STRAPSRC := variables.scm match.scm utils.scm getopt.scm expand.scm cps.scm transpile.scm frontend.scm ffi.scm
STRAP = $(addprefix bootstrap/src/, $(STRAPSRC:.scm=.c))

VSCHEME = libvscheme.so.$(MAJOR)
VSC = vsc.$(MAJOR)

include config.mk

.PHONY : deps install compiler runtime tests install_compiler lay_egg hatch testffi
compiler : bin/vsc
runtime : lib/libvscheme.so

# the include copy doesn't have an -u on it because
# include files aren't build. Can add the -u if we
# copy the files to the bin directory
install : compiler runtime
	cp -u lib/libvscheme.so ~/.local/lib/$(VSCHEME)
	mkdir -p ~/.local/include/vscheme/
	mkdir -p ~/.local/lib/
	cp -r include/* ~/.local/include/.
	cp -u bin/vsc ~/.local/bin/$(VSC)

tests : compiler runtime
	@for test in $(addprefix test/, $(TEST_SRC)) ; do \
		echo "bin/vsc $$test && ./a.out" ; \
    OVERRIDE=`realpath lib/` ; \
		if ! (LD_LIBRARY_PATH=$$OVERRIDE:$$LD_LIBRARY_PATH bin/vsc $$test -Wc,-Iinclude -Wc,-lm ) ; then \
			echo "COMPILE FAILURE: $$test"; \
			break; \
	  fi ; \
    EXE=`realpath a.out` ; \
		if ! (cd `dirname $$test` ; LD_LIBRARY_PATH=$$OVERRIDE:$$LD_LIBRARY_PATH $$EXE) ; then \
			echo "FAILURE: $$test"; \
			break; \
		fi \
	done

lay_egg : $(BOOT) bin/bootstrap/runtime/r7rs.c
	cp -r include bin/bootstrap/.
	yacc -d -b ffi src/ffi.y
	mv ffi.tab.h bin/bootstrap/src/
	mv ffi.tab.c bin/bootstrap/src/
	lex -t src/ffi.l > bin/bootstrap/src/ffi.lex.c

# Pretty horribly messy, should seperate into a Makefile.hatch
hatch :
	cp -ar bootstrap/include/* ~/.local/include/.
	gcc -rdynamic -c -o build/r7rs.o bootstrap/runtime/r7rs.c -Ibootstrap/include $(LIBS) $(CFLAGS) -fPIC -Wno-missing-braces
	gcc -rdynamic -o lib/libvscheme.so build/r7rs.o $(addprefix bootstrap/runtime/, $(RUNTIME_SRC)) bootstrap/runtime/vapply-linux-x64.s -Ibootstrap/include $(LIBS) $(CFLAGS) -fPIC -shared -Wno-missing-braces -masm=intel
	cp -a lib/libvscheme.so ~/.local/lib/$(VSCHEME)
	gcc -rdynamic -o bin/vsc $(STRAP) $(CFLAGS) bootstrap/src/ffi.tab.c bootstrap/src/ffi.lex.c -Ibootstrap/include -lvscheme -Wl,--no-as-needed -Wno-missing-braces
	cp -a bin/vsc ~/.local/bin/$(VSC)
# artifact of my idiotic decision to not put runtime and src in seperate folders in boostrap
bin/bootstrap/runtime/r7rs.c : runtime/r7rs.scm
	vsc -t $< -o $@ $(SCMFLAGS) --shared
	{ /bin/rm $@; cat misc/license_template - >$@; } <$@	
bin/bootstrap/src/%.c : src/%.scm
	vsc -t $< -o $@ $(SCMFLAGS)
	{ /bin/rm $@; cat misc/license_template - >$@; } <$@	
bin/bootstrap/runtime/%.c : runtime/%.c
	cp $< $@
bin/bootstrap/runtime/%.s : runtime/%.s
	cp $< $@

deps : $(DEP)

build/%.d : runtime/%.c
	gcc $< -MG -MM -MF $@ -MT $@ -MT $(@:.d=.o) $(CFLAGS) $(IFLAGS)
build/%.d : runtime/%.s
	echo '$(@,.d=.o) $@: $<' > $@

-include $(DEP)

bin/vsc : $(OBJ)
	vsc -o $@ $^ $(SCMFLAGS)
lib/libvscheme.so : $(RUNTIME_OBJ) build/r7rs.o
	gcc -o $@ $^ $(LIBS) $(CFLAGS) -shared

# Think long and hard why you need -Wc,-Iinclude sometimes to get it working
# but other times you need to not have -Wc,-Iinclude

# I think you need the include when you change ABI but not API
# and you need to not have the include when you break API but not ABI
# and if you break both you're fucked.

build/r7rs.o : runtime/r7rs.scm
	vsc runtime/r7rs.scm -c -o build/r7rs.o $(SCMFLAGS) --shared

build/%.o : runtime/%.c build/%.d 
	gcc -c $< -o $@ $(CFLAGS) $(IFLAGS)

build/%.o : runtime/%.s 
	gcc -c $< -o $@ $(CFLAGS) $(IFLAGS)

build/%.o : src/%.scm
	vsc -c $< -o $@ $(SCMFLAGS)

build/ffi.lex.c : src/ffi.l
	lex -t $< > $@

# Horrifically, we must use a pattern rule here to force make to understand these
# targets are built simultaneously
build/%.tab.h build/%.tab.c : src/%.y
	yacc -d -b ffi $< && mv ffi.tab.h build/ && mv ffi.tab.c build/

build/ffi.lex.o build/ffi.tab.o : include/vscheme/vmemory.h include/vscheme/vruntime.h include/vscheme/vinlines.h 

build/ffi.lex.o : build/ffi.lex.c build/ffi.tab.h
	gcc -c $< -o $@ $(CFLAGS)

build/ffi.tab.o : build/ffi.tab.c
	gcc -c $< -o $@ $(CFLAGS)

bin/testffi : build/ffi.lex.o build/ffi.tab.o test/testffi.c
	gcc -o $@ $^ $(CFLAGS) -lvscheme

testffi : bin/testffi
